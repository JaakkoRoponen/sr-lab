<!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <title>Lorentz 3D Simulaattori - Pituuden lyheneminen</title>
    <style>
        body {
            margin: 0;
            background: #020617;
            color: white;
            font-family: sans-serif;
            overflow: hidden;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(15, 23, 42, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #334155;
            z-index: 100;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: #38bdf8;
            margin-top: 5px;
        }

        .label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            background: #1e293b;
            color: white;
            border: 1px solid #475569;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.82em;
            transition: all 0.2s;
            text-align: left;
        }

        button:hover {
            background: #334155;
            border-color: #38bdf8;
        }

        button.active {
            border-left: 4px solid #38bdf8;
        }

        button.off {
            opacity: 0.5;
            border-left: 4px solid #f43f5e;
        }
    </style>
</head>

<body>

    <div id="ui">
        <h3 style="margin: 0 0 10px 0; color: #facc15;">Lorentz Hallinta</h3>

        <div class="label">Nopeus (v/c): <b id="v-val">0.00</b></div>
        <input type="range" id="v-slider" min="-0.95" max="0.99" step="0.01" value="0">

        <div class="label" style="margin-top:10px;">Lepopituus (L'): <b id="l-val">20.00</b></div>
        <input type="range" id="l-slider" min="0" max="50" step="1" value="0">

        <div class="label" style="margin-top:10px;">Oma aika (t'): <b id="t-val">0.00</b></div>
        <input type="range" id="t-slider" min="-40" max="40" step="0.1" value="0">

        <div class="controls">
            <button id="btn-grid" class="active" data-on="Taso: PÄÄLLÄ" data-off="Taso: POIS">Taso: PÄÄLLÄ</button>
            <button id="btn-follow" class="active" data-on="Liikkuva taso: PÄÄLLÄ" data-off="Liikkuva taso: POIS">Liikkuva taso: PÄÄLLÄ</button>
            <button id="btn-camera" class="off" data-on="Kameran seuranta: PÄÄLLÄ" data-off="Kameran seuranta: POIS">Kameran seuranta: POIS</button>
            <button id="btn-axes" class="off" data-on="Akselit: PÄÄLLÄ" data-off="Akselit: POIS">Akselit: POIS</button>
            <button id="btn-future" class="active" data-on="Tulevaisuus: PÄÄLLÄ" data-off="Tulevaisuus: POIS">Tulevaisuus: PÄÄLLÄ</button>
            <button id="btn-past" class="active" data-on="Menneisyys: PÄÄLLÄ" data-off="Menneisyys: POIS">Menneisyys: PÄÄLLÄ</button>
            <button id="btn-mode" class="active">Valo: Pallot (1D)</button>
            <button id="btn-line" class="active" data-on="Maailmanviivat: PÄÄLLÄ" data-off="Maailmanviivat: POIS">Maailmanviivat: PÄÄLLÄ</button>
        </div>
    </div>

    <script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.set(45, 30, 45);
        const controls = new OrbitControls(camera, renderer.domElement);

        // Objects
        const L_cone = 100;
        const numBalls = 64;
        const lineMat = new THREE.LineBasicMaterial({ color: 0xfacc15, transparent: true, opacity: 0.6 });

        const createCone = (isFuture) => {
            const group = new THREE.Group();
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(L_cone, L_cone, numBalls, 1, true),
                new THREE.MeshBasicMaterial({ color: 0xfacc15, wireframe: true, transparent: true, opacity: 0.1, side: THREE.DoubleSide })
            );
            cone.position.y = isFuture ? L_cone / 2 : -L_cone / 2;
            if (isFuture) cone.rotation.x = Math.PI;

            const l1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(L_cone, isFuture ? L_cone : -L_cone, 0)]), lineMat);
            const l2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(-L_cone, isFuture ? L_cone : -L_cone, 0)]), lineMat);

            group.add(cone, l1, l2);
            return { group, cone, l1, l2 };
        };

        const future = createCone(true);
        const past = createCone(false);
        scene.add(future.group, past.group);

        const movingSystem = new THREE.Group();
        const gridHelper = new THREE.GridHelper(100, 50, 0x38bdf8, 0x1e293b);
        movingSystem.add(gridHelper);
        scene.add(movingSystem);

        const ringBalls = Array.from({ length: numBalls }, () => {
            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            scene.add(ball);
            return ball;
        });

        // Maailmanviivat
        const leftLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf43f5e }));
        const rightLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf43f5e }));
        const worldLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x10b981, transparent: true, opacity: 0.5 }));
        scene.add(leftLine, rightLine, worldLine);

        // Laboratorioakselit (Harmaat)
        const axisMat = new THREE.LineBasicMaterial({ color: 0x64748b, transparent: true, opacity: 0.8 });
        const labXAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-200, 0, 0), new THREE.Vector3(200, 0, 0)]), axisMat);
        const labTAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -200, 0), new THREE.Vector3(0, 200, 0)]), axisMat);
        labXAxis.visible = labTAxis.visible = false;
        scene.add(labXAxis, labTAxis);

        // State & UI
        const state = { lightMode: 1, followTime: true, cameraFollow: false, showLines: true, showAxes: false, showGrid: true };
        const ui = {
            v: document.getElementById('v-slider'),
            t: document.getElementById('t-slider'),
            l: document.getElementById('l-slider'),
            vDisp: document.getElementById('v-val'),
            tDisp: document.getElementById('t-val'),
            lDisp: document.getElementById('l-val')
        };

        const updateBtn = (btn, active) => {
            btn.classList.toggle('active', active);
            btn.classList.toggle('off', !active);
            btn.innerText = active ? btn.dataset.on : btn.dataset.off;
        };

        // Event Listeners
        document.getElementById('btn-camera').onclick = (e) => { state.cameraFollow = !state.cameraFollow; updateBtn(e.target, state.cameraFollow); };
        document.getElementById('btn-follow').onclick = (e) => { state.followTime = !state.followTime; updateBtn(e.target, state.followTime); };
        document.getElementById('btn-grid').onclick = (e) => { state.showGrid = !state.showGrid; updateBtn(e.target, state.showGrid); gridHelper.visible = state.showGrid; };
        document.getElementById('btn-future').onclick = (e) => { future.group.visible = !future.group.visible; updateBtn(e.target, future.group.visible); };
        document.getElementById('btn-past').onclick = (e) => { past.group.visible = !past.group.visible; updateBtn(e.target, past.group.visible); };
        document.getElementById('btn-axes').onclick = (e) => {
            state.showAxes = !state.showAxes;
            updateBtn(e.target, state.showAxes);
            labXAxis.visible = labTAxis.visible = state.showAxes;
        };
        document.getElementById('btn-line').onclick = (e) => {
            state.showLines = !state.showLines;
            updateBtn(e.target, state.showLines);
            leftLine.visible = rightLine.visible = worldLine.visible = state.showLines;
        };

        document.getElementById('btn-mode').onclick = (e) => {
            state.lightMode = (state.lightMode + 1) % 3;
            const labels = ["Valo: PIILOTETTU", "Valo: Pallot (1D)", "Valo: Rengas (2D)"];
            e.target.innerText = labels[state.lightMode];
            e.target.className = state.lightMode === 0 ? 'off' : 'active';
        };

        // Tuplaklikkaus nollaa sliderit
        ui.v.ondblclick = () => ui.v.value = 0;
        ui.t.ondblclick = () => ui.t.value = 0;
        ui.l.ondblclick = () => ui.l.value = 0;

        function animate() {
            requestAnimationFrame(animate);

            const v = parseFloat(ui.v.value);
            const tp = parseFloat(ui.t.value);
            const L_prime = parseFloat(ui.l.value);
            const gamma = 1 / Math.sqrt(1 - v * v);
            const angle = Math.atan(v);

            ui.vDisp.innerText = v.toFixed(2);
            ui.tDisp.innerText = tp.toFixed(2);
            ui.lDisp.innerText = L_prime.toFixed(2);

            future.cone.visible = past.cone.visible = (state.lightMode === 2);
            future.l1.visible = future.l2.visible = past.l1.visible = past.l2.visible = (state.lightMode === 1);

            const oldPos = movingSystem.position.clone();
            movingSystem.position.set(state.followTime ? gamma * v * tp : 0, state.followTime ? gamma * tp : 0, 0);
            movingSystem.rotation.z = angle;
            movingSystem.scale.x = 1;

            const pointsL = [], pointsR = [], pointsC = [];
            for (let t_line = -100; t_line <= 100; t_line += 5) {
                pointsC.push(new THREE.Vector3(gamma * (v * t_line), gamma * t_line, 0));
                pointsL.push(new THREE.Vector3(gamma * (-L_prime / 2 + v * t_line), gamma * (t_line + v * (-L_prime / 2)), 0));
                pointsR.push(new THREE.Vector3(gamma * (L_prime / 2 + v * t_line), gamma * (t_line + v * (L_prime / 2)), 0));
            }
            leftLine.geometry.setFromPoints(pointsL);
            rightLine.geometry.setFromPoints(pointsR);
            worldLine.geometry.setFromPoints(pointsC);

            ringBalls.forEach((ball, i) => {
                const isVisible = state.lightMode !== 0 && (state.lightMode === 2 || i === 0 || i === numBalls / 2);
                ball.visible = isVisible;

                if (isVisible) {
                    const phi = (i / numBalls) * Math.PI * 2;
                    const xp = Math.cos(phi) * tp;
                    const zp = Math.sin(phi) * tp;
                    ball.position.set(gamma * (xp + v * tp), gamma * (tp + v * xp), zp);
                }
            });

            if (state.cameraFollow) {
                const delta = movingSystem.position.clone().sub(oldPos);
                camera.position.add(delta);
                controls.target.add(delta);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>

</html>
