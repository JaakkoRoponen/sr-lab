<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Lorentz Simulator</title>
    <style>
        :root {
            --bg-primary: #020617;
            --bg-panel: rgba(15, 23, 42, 0.95);
            --bg-button: #1e293b;
            --bg-button-hover: #334155;
            --border-primary: #334155;
            --border-secondary: #475569;
            --accent: #38bdf8;
            --accent-warning: #f43f5e;
            --accent-gold: #facc15;
            --text-primary: white;
        }

        body {
            margin: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: var(--bg-panel);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-primary);
            z-index: 100;
        }

        h3 {
            margin: 0 0 10px 0;
            color: var(--accent-gold);
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group:first-of-type {
            margin-top: 0;
        }

        .label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--accent);
            margin-top: 5px;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            background: var(--bg-button);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.82em;
            transition: all 0.2s;
            text-align: left;
        }

        button:hover {
            background: var(--bg-button-hover);
            border-color: var(--accent);
        }

        button.active {
            border-left: 4px solid var(--accent);
        }

        button.off {
            opacity: 0.5;
            border-left: 4px solid var(--accent-warning);
        }

        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-primary);
        }

        .stats h4 {
            margin: 0 0 10px 0;
            font-size: 0.85em;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            padding: 4px 0;
            border-bottom: 1px solid rgba(51, 65, 85, 0.5);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #94a3b8;
        }

        .stat-value {
            font-family: 'SF Mono', 'Fira Code', monospace;
            color: var(--accent-gold);
        }

        .stat-value.highlight {
            color: var(--accent);
        }

        .stat-formula {
            font-size: 0.75em;
            color: #64748b;
            margin-top: 2px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>Lorentz Simulator</h3>

        <div class="slider-group">
            <div class="label">Velocity (v/c): <b id="v-val">0.00</b></div>
            <input type="range" id="v-slider" min="-0.95" max="0.99" step="0.01" value="0">
        </div>

        <div class="slider-group">
            <div class="label">Rest length (L'): <b id="l-val">0.00</b></div>
            <input type="range" id="l-slider" min="0" max="50" step="1" value="0">
        </div>

        <div class="slider-group">
            <div class="label">Proper time (t'): <b id="t-val">0.00</b></div>
            <input type="range" id="t-slider" min="-40" max="40" step="0.1" value="0">
        </div>

        <div class="controls">
            <button id="btn-grid" class="active" data-on="Grid: ON" data-off="Grid: OFF">Grid: ON</button>
            <button id="btn-follow" class="active" data-on="Moving grid: ON" data-off="Moving grid: OFF">Moving grid: ON</button>
            <button id="btn-camera" class="off" data-on="Camera follow: ON" data-off="Camera follow: OFF">Camera follow: OFF</button>
            <button id="btn-axes" class="off" data-on="Axes: ON" data-off="Axes: OFF">Axes: OFF</button>
            <button id="btn-future" class="active" data-on="Future cone: ON" data-off="Future cone: OFF">Future cone: ON</button>
            <button id="btn-past" class="active" data-on="Past cone: ON" data-off="Past cone: OFF">Past cone: ON</button>
            <button id="btn-mode" class="active">Light: Spheres (1D)</button>
            <button id="btn-line" class="active" data-on="Worldlines: ON" data-off="Worldlines: OFF">Worldlines: ON</button>
            <button id="btn-rods" class="active" data-on="Length rods: ON" data-off="Length rods: OFF">Length rods: ON</button>
            <button id="btn-simul" class="active" data-on="Simultaneity: ON" data-off="Simultaneity: OFF">Simultaneity: ON</button>
        </div>

        <div class="stats">
            <h4>Lab Frame Observations</h4>
            <div class="stat-row">
                <span class="stat-label">Lorentz factor (γ)</span>
                <span class="stat-value highlight" id="stat-gamma">1.00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Lab time (t)</span>
                <span class="stat-value" id="stat-t">0.00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Lab position (x)</span>
                <span class="stat-value" id="stat-x">0.00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Observed length (L)</span>
                <span class="stat-value" id="stat-l">0.00</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Length contraction</span>
                <span class="stat-value" id="stat-contraction">1.00×</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Time dilation</span>
                <span class="stat-value" id="stat-dilation">1.00×</span>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            cone: {
                size: 100,
                segments: 64
            },
            colors: {
                lightCone: 0xfacc15,
                grid: { primary: 0x38bdf8, secondary: 0x1e293b },
                worldline: { center: 0x10b981, edges: 0xf43f5e },
                axes: 0x64748b,
                lightBalls: 0xffffff,
                rod: {
                    rest: 0x38bdf8,      // Cyan - rest length in moving frame
                    contracted: 0xf472b6  // Pink - contracted length in lab frame
                },
                simultaneity: 0xf472b6   // Pink - lab frame "now" (horizontal)
            },
            camera: {
                fov: 75,
                near: 0.1,
                far: 2000,
                initialPosition: { x: 45, y: 30, z: 45 }
            },
            worldline: {
                range: 100,
                step: 5
            }
        };

        // ============================================
        // PHYSICS UTILITIES
        // ============================================
        const Physics = {
            /** Calculate Lorentz factor γ = 1/√(1 - v²) */
            gamma(v) {
                return 1 / Math.sqrt(1 - v * v);
            },

            /** Lorentz transform from moving frame (x', t') to lab frame (x, t) */
            lorentzTransform(xPrime, tPrime, v) {
                const g = this.gamma(v);
                return {
                    x: g * (xPrime + v * tPrime),
                    t: g * (tPrime + v * xPrime)
                };
            },

            /** Get simultaneity angle for spacetime diagram */
            simultaneityAngle(v) {
                return Math.atan(v);
            }
        };

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            CONFIG.camera.fov,
            window.innerWidth / window.innerHeight,
            CONFIG.camera.near,
            CONFIG.camera.far
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.set(
            CONFIG.camera.initialPosition.x,
            CONFIG.camera.initialPosition.y,
            CONFIG.camera.initialPosition.z
        );
        const controls = new OrbitControls(camera, renderer.domElement);

        // ============================================
        // SCENE OBJECTS
        // ============================================

        /** Create a light cone (future or past) */
        function createLightCone(isFuture) {
            const { size, segments } = CONFIG.cone;
            const color = CONFIG.colors.lightCone;

            const group = new THREE.Group();

            // Wireframe cone mesh
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(size, size, segments, 1, true),
                new THREE.MeshBasicMaterial({
                    color,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                })
            );
            cone.position.y = isFuture ? size / 2 : -size / 2;
            if (isFuture) cone.rotation.x = Math.PI;

            // 1D light lines (x-axis only)
            const lineMat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.6 });
            const yDir = isFuture ? size : -size;

            const line1 = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(size, yDir, 0)
                ]),
                lineMat
            );
            const line2 = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(-size, yDir, 0)
                ]),
                lineMat
            );

            group.add(cone, line1, line2);

            return { group, cone, lines: [line1, line2] };
        }

        /** Create lab frame coordinate axes */
        function createLabAxes() {
            const axisMat = new THREE.LineBasicMaterial({
                color: CONFIG.colors.axes,
                transparent: true,
                opacity: 0.8
            });
            const range = 200;

            const xAxis = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-range, 0, 0),
                    new THREE.Vector3(range, 0, 0)
                ]),
                axisMat
            );
            const tAxis = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -range, 0),
                    new THREE.Vector3(0, range, 0)
                ]),
                axisMat
            );

            xAxis.visible = false;
            tAxis.visible = false;

            return { x: xAxis, t: tAxis };
        }

        /** Create worldline objects */
        function createWorldlines() {
            const edgeMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.worldline.edges });
            const centerMat = new THREE.LineBasicMaterial({
                color: CONFIG.colors.worldline.center,
                transparent: true,
                opacity: 0.5
            });

            return {
                left: new THREE.Line(new THREE.BufferGeometry(), edgeMat),
                right: new THREE.Line(new THREE.BufferGeometry(), edgeMat),
                center: new THREE.Line(new THREE.BufferGeometry(), centerMat)
            };
        }

        /** Create light pulse visualization balls */
        function createLightBalls(count) {
            return Array.from({ length: count }, () => {
                const ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 16, 16),
                    new THREE.MeshBasicMaterial({ color: CONFIG.colors.lightBalls })
                );
                scene.add(ball);
                return ball;
            });
        }

        /** Create visual rods for length comparison */
        function createLengthRods() {
            const rodHeight = 1.5;
            const rodDepth = 0.5;

            // Rest length rod (moving frame) - cyan
            const restRod = new THREE.Mesh(
                new THREE.BoxGeometry(1, rodHeight, rodDepth),
                new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.rod.rest,
                    transparent: true,
                    opacity: 0.9
                })
            );

            // Contracted length rod (lab frame) - pink
            const contractedRod = new THREE.Mesh(
                new THREE.BoxGeometry(1, rodHeight, rodDepth),
                new THREE.MeshBasicMaterial({
                    color: CONFIG.colors.rod.contracted,
                    transparent: true,
                    opacity: 0.7
                })
            );

            return {
                rest: restRod,
                contracted: contractedRod
            };
        }

        /** Create lab frame "now" line */
        function createLabNowLine() {
            return new THREE.Line(
                new THREE.BufferGeometry(),
                new THREE.LineBasicMaterial({ color: CONFIG.colors.simultaneity, transparent: true, opacity: 0.6 })
            );
        }

        // Initialize scene objects
        const futureCone = createLightCone(true);
        const pastCone = createLightCone(false);
        scene.add(futureCone.group, pastCone.group);

        const movingFrame = new THREE.Group();
        const grid = new THREE.GridHelper(100, 50, CONFIG.colors.grid.primary, CONFIG.colors.grid.secondary);
        movingFrame.add(grid);
        scene.add(movingFrame);

        const lightBalls = createLightBalls(CONFIG.cone.segments);

        const worldlines = createWorldlines();
        scene.add(worldlines.left, worldlines.right, worldlines.center);

        const labAxes = createLabAxes();
        scene.add(labAxes.x, labAxes.t);

        const lengthRods = createLengthRods();
        scene.add(lengthRods.rest, lengthRods.contracted);

        const labNowLine = createLabNowLine();
        scene.add(labNowLine);

        // ============================================
        // APPLICATION STATE
        // ============================================
        const state = {
            lightMode: 1,           // 0: hidden, 1: spheres (1D), 2: ring (2D)
            followTime: true,       // Moving grid follows proper time
            cameraFollow: false,    // Camera follows moving frame
            showLines: true,        // Show worldlines
            showAxes: false,        // Show lab frame axes
            showGrid: true,         // Show moving frame grid
            showRods: true,         // Show length comparison rods
            showSimultaneity: true  // Show simultaneity markers
        };

        // ============================================
        // UI ELEMENTS
        // ============================================
        const ui = {
            sliders: {
                v: document.getElementById('v-slider'),
                t: document.getElementById('t-slider'),
                l: document.getElementById('l-slider')
            },
            displays: {
                v: document.getElementById('v-val'),
                t: document.getElementById('t-val'),
                l: document.getElementById('l-val')
            },
            stats: {
                gamma: document.getElementById('stat-gamma'),
                t: document.getElementById('stat-t'),
                x: document.getElementById('stat-x'),
                l: document.getElementById('stat-l'),
                contraction: document.getElementById('stat-contraction'),
                dilation: document.getElementById('stat-dilation')
            }
        };

        /** Update toggle button state and text */
        function updateButton(btn, active) {
            btn.classList.toggle('active', active);
            btn.classList.toggle('off', !active);
            btn.innerText = active ? btn.dataset.on : btn.dataset.off;
        }

        /** Create a toggle handler for a state property */
        function createToggleHandler(stateKey, onToggle) {
            return (e) => {
                state[stateKey] = !state[stateKey];
                updateButton(e.target, state[stateKey]);
                onToggle?.(state[stateKey]);
            };
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        // Toggle buttons
        document.getElementById('btn-grid').onclick =
            createToggleHandler('showGrid', (on) => grid.visible = on);

        document.getElementById('btn-follow').onclick =
            createToggleHandler('followTime');

        document.getElementById('btn-camera').onclick =
            createToggleHandler('cameraFollow');

        document.getElementById('btn-axes').onclick =
            createToggleHandler('showAxes', (on) => labAxes.x.visible = labAxes.t.visible = on);

        document.getElementById('btn-line').onclick =
            createToggleHandler('showLines', (on) => {
                worldlines.left.visible = worldlines.right.visible = worldlines.center.visible = on;
            });

        document.getElementById('btn-rods').onclick =
            createToggleHandler('showRods', (on) => {
                lengthRods.rest.visible = on;
                lengthRods.contracted.visible = on;
            });

        document.getElementById('btn-simul').onclick =
            createToggleHandler('showSimultaneity', (on) => labNowLine.visible = on);

        document.getElementById('btn-future').onclick = (e) => {
            futureCone.group.visible = !futureCone.group.visible;
            updateButton(e.target, futureCone.group.visible);
        };

        document.getElementById('btn-past').onclick = (e) => {
            pastCone.group.visible = !pastCone.group.visible;
            updateButton(e.target, pastCone.group.visible);
        };

        document.getElementById('btn-mode').onclick = (e) => {
            state.lightMode = (state.lightMode + 1) % 3;
            const labels = ['Light: HIDDEN', 'Light: Spheres (1D)', 'Light: Ring (2D)'];
            e.target.innerText = labels[state.lightMode];
            e.target.className = state.lightMode === 0 ? 'off' : 'active';
        };

        // Double-click to reset sliders
        ui.sliders.v.ondblclick = () => ui.sliders.v.value = 0;
        ui.sliders.t.ondblclick = () => ui.sliders.t.value = 0;
        ui.sliders.l.ondblclick = () => ui.sliders.l.value = 0;

        // Window resize
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        // ============================================
        // ANIMATION LOOP
        // ============================================

        /** Calculate worldline points for an object at x' position */
        function calculateWorldlinePoints(xPrime, v, gamma) {
            const { range, step } = CONFIG.worldline;
            const points = [];

            for (let tPrime = -range; tPrime <= range; tPrime += step) {
                const transformed = Physics.lorentzTransform(xPrime, tPrime, v);
                points.push(new THREE.Vector3(transformed.x, transformed.t, 0));
            }

            return points;
        }

        /** Update light ball positions */
        function updateLightBalls(v, gamma, tPrime) {
            const numBalls = CONFIG.cone.segments;

            lightBalls.forEach((ball, i) => {
                // In 1D mode, only show two balls (front and back)
                const isVisible = state.lightMode !== 0 &&
                    (state.lightMode === 2 || i === 0 || i === numBalls / 2);
                ball.visible = isVisible;

                if (isVisible) {
                    const phi = (i / numBalls) * Math.PI * 2;
                    const xPrime = Math.cos(phi) * tPrime;
                    const zPrime = Math.sin(phi) * tPrime;

                    const transformed = Physics.lorentzTransform(xPrime, tPrime, v);
                    ball.position.set(transformed.x, transformed.t, zPrime);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Read current values
            const v = parseFloat(ui.sliders.v.value);
            const tPrime = parseFloat(ui.sliders.t.value);
            const lPrime = parseFloat(ui.sliders.l.value);

            // Calculate physics
            const gamma = Physics.gamma(v);
            const angle = Physics.simultaneityAngle(v);

            // Update UI displays
            ui.displays.v.innerText = v.toFixed(2);
            ui.displays.t.innerText = tPrime.toFixed(2);
            ui.displays.l.innerText = lPrime.toFixed(2);

            // Calculate lab frame values
            const labCoords = Physics.lorentzTransform(0, tPrime, v);
            const contractedLength = lPrime / gamma;  // Length contraction: L = L'/γ

            // Update stats panel
            ui.stats.gamma.innerText = gamma.toFixed(3);
            ui.stats.t.innerText = labCoords.t.toFixed(2);
            ui.stats.x.innerText = labCoords.x.toFixed(2);
            ui.stats.l.innerText = contractedLength.toFixed(2);
            ui.stats.contraction.innerText = (1 / gamma).toFixed(3) + '×';
            ui.stats.dilation.innerText = gamma.toFixed(3) + '×';

            // Update light cone visibility based on mode
            const show2D = state.lightMode === 2;
            const show1D = state.lightMode === 1;
            futureCone.cone.visible = pastCone.cone.visible = show2D;
            futureCone.lines.forEach(l => l.visible = show1D);
            pastCone.lines.forEach(l => l.visible = show1D);

            // Update moving reference frame
            const oldPos = movingFrame.position.clone();
            if (state.followTime) {
                const origin = Physics.lorentzTransform(0, tPrime, v);
                movingFrame.position.set(origin.x, origin.t, 0);
            } else {
                movingFrame.position.set(0, 0, 0);
            }
            movingFrame.rotation.z = angle;

            // Update worldlines
            worldlines.center.geometry.setFromPoints(calculateWorldlinePoints(0, v, gamma));
            worldlines.left.geometry.setFromPoints(calculateWorldlinePoints(-lPrime / 2, v, gamma));
            worldlines.right.geometry.setFromPoints(calculateWorldlinePoints(lPrime / 2, v, gamma));

            // Update light balls
            updateLightBalls(v, gamma, tPrime);

            // Update length comparison rods
            if (state.showRods && lPrime > 0) {
                // REST LENGTH ROD (cyan) - in moving frame at proper time t'
                // This rod is along the simultaneity surface of the moving frame
                const leftEnd = Physics.lorentzTransform(-lPrime / 2, tPrime, v);
                const rightEnd = Physics.lorentzTransform(lPrime / 2, tPrime, v);

                // Position and rotate the rest rod
                const restCenterX = (leftEnd.x + rightEnd.x) / 2;
                const restCenterT = (leftEnd.t + rightEnd.t) / 2;
                lengthRods.rest.position.set(restCenterX, restCenterT, 0);
                lengthRods.rest.rotation.z = angle;
                lengthRods.rest.scale.x = lPrime;
                lengthRods.rest.visible = true;

                // CONTRACTED LENGTH ROD (pink) - what lab frame sees at lab time t
                // Both ends measured at the SAME lab time (horizontal slice)
                const labT = labCoords.t;
                // At lab time t, where are the left and right ends?
                // x = x'/γ + vt (derived from Lorentz transform)
                const leftLabX = -lPrime / (2 * gamma) + v * labT;
                const rightLabX = lPrime / (2 * gamma) + v * labT;

                lengthRods.contracted.position.set((leftLabX + rightLabX) / 2, labT, 0.8);
                lengthRods.contracted.rotation.z = 0; // Horizontal in lab frame
                lengthRods.contracted.scale.x = contractedLength;
                lengthRods.contracted.visible = true;
            } else {
                // Hide rods if L' = 0 or rods disabled
                lengthRods.rest.visible = false;
                lengthRods.contracted.visible = false;
            }

            // Update lab frame "now" line (horizontal at current lab time)
            const labT = labCoords.t;
            labNowLine.geometry.setFromPoints([
                new THREE.Vector3(labCoords.x - 60, labT, 0.5),
                new THREE.Vector3(labCoords.x + 60, labT, 0.5)
            ]);
            labNowLine.visible = state.showSimultaneity;

            // Camera follow mode
            if (state.cameraFollow) {
                const delta = movingFrame.position.clone().sub(oldPos);
                camera.position.add(delta);
                controls.target.add(delta);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>
